<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[英文文献阅读]]></title>
    <url>%2F2017%2F06%2F03%2F%E8%8B%B1%E6%96%87%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[Abstract一些英文文献的简要翻译 Efficient FPGA Implementation of OpenCL High-Performance Computing Applications via High-Level Synthesis 最近 在当代高性能计算系统中，基于FPGA的加速器已经演变为传统的基于GPU加速器的强有力对手。基于FPGA的加速器在用有高性能计算能力的同时，消耗的能量又非常的少。而高级综合能通过使用高级编程语言直接对FPGA进行编程，如C/C++/OpenCL。以执行时间、能耗，作为性能指标，比较了高端GPU和FPGA的性能情况。 介绍导致当今片上系统异构计算的发展，异构系统缓解了多核扩展的问题，内存墙，冯诺依曼瓶颈，如在SMP任务调度中，决定任务在哪几个核上执行最有效率是一个NP-Hard问题 异构系统是由多核处理器和各种各样的加速计算密集型任务执行的硬件加速器组成。 GPU拥有更好的浮点吞吐量，是一种倾向于数据并行的架构，并且比处理器拥有更好的内存带宽（能量消耗较大）。这些优点使得GPU被应用于HPC(高性能计算系统)中，但是能耗比较大。 FPGA提供相对可观的计算性能的同时，消耗更少的能量。每一代FPGA之间，性能差距不断增加，而多核CPU却没有这样的优势。不断增加的性能和超高的能量利用率使得FPGA比GPU、CPU的能效比都要高。这些能力已经被一些像百度和微软这样的大数据公司所认可。 使用FPGA的一个困难之一是FPGA编程的复杂性。FPGA通常使用HDL（Verilog，VHDL）编程，门槛比较高，而这个困难可以通过高级综合（HLS）来解决。使用高级语言对FPGA编程也减少验证和设计所花费的时间。 因为硬件架构和代码必须相互吻合，同一套OpenCL代码在不同的GPU上执行的性能可能不一样，在GPU上执行性能相差更远。所以OpenCL代码必须是针对特定的硬件架构的，在论文的后面会证明这些适配工作是值得。 异构编程中，需要建立起内存不是平的。是由外部DRAM组成的global， 片上的SRAM组成的local，私有寄存器的private内存结构模型。 OpenCL在不同硬件上适配性使其超过了CUDA，但是OpenCL本身不提供不同硬件自动优化的能力。 前面提高，访问外部全局内存FPGA没有FPGA快，GPU尽管比较快，但是消耗的能量非常大，所以合理使用片上资源是关键，FPGA拥有自己的片上内存，方便kernel之间相互通信，减少对了外部全局内存的访问，同时FPGA的控制逻辑都是由硬件电路实现的，不需要取指和译码，并且片上内存还可以根据需要裁剪以便更好地适应程序执行，当然这些是通过一些高级综合编译指向（directive）来实现的。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OpenCL</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DPDK 介绍]]></title>
    <url>%2F2017%2F05%2F19%2FDPDK-%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[AbstractDPDK是Intel在IA框架下开发的数据面开发套件，运用了DDIO、NUMA、AVX、HugePage的数据面开发套件。 Getting Started Guide 讲述怎么安装和配置DPDK，旨在让用户快速入手。 在linux环境中使用大页技术在为数据包分配内存的大内存池需要大页技术的支持。通过使用大页分配，减少了程序使用页的个数，这样TLB中的记录就会减少，缺页的概率降低，将虚拟页的地址转换为物理地址的时间也会减少，程序性能从而得到提高。 大页在系统启动的时候就已经分配好，或者在系统启动阻止内存映射道物理内存中去的时候。为了在启动时保留大页，使用命令行为kernel启动添加参数。 从源码编译DPDK可执行文件• lib: Source code of DPDK libraries• drivers: Source code of DPDK poll-mode drivers• app: Source code of DPDK applications (automatic tests)• examples: Source code of DPDK application examples• conﬁg, buildtools, mk: Framework-related makeﬁles, scripts and conﬁguration 安装脚本 1234make install T=x86_64-native-linuxapp-gccsudo modprobe uio_pci_genericsudo modprobe uiosudo insmod kmod/igb_uio.ko]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>DPDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bash Environment On Windows]]></title>
    <url>%2F2017%2F05%2F11%2FBash-Environment-On-Windows%2F</url>
    <content type="text"><![CDATA[AbstractWindows 下使用bash环境的一些配置，bash是基于cmder和git自带的bash，通过配置PS1使得交互更好看。virtualenv可以使得在每个Python项目都有一个干净的环境。 pip 安装windows 高版本python一般都自带pip，如果没有的话去Python的官网下载 12345# 解压后，进入该目录执行python setup.py install# linux安装sudo apt-get intall python-pip 源配置 1234567891011121314# Windows源配置1. 在C:\Users\Harvey目录下创建pip文件夹2. 新建pip.in文件# Linux源配置1. /home/harvey/目录下创建.pip文件夹2. 新建pip.conf# pip.conf&amp;pip.ini内容[global]format = columnstimeout = 60index-url = http://pypi.douban.com/simpletrusted-host = pypi.douban.com virtualenv123456789101112pip install virtualenv# 新建一个名字为 venv_name 的虚拟环境，并不拷入系统已经安装好的包virtualenv --no-site-packages venv_name -p python_version.exe# windowssource venv_name/Scripts/activatewhich pip #查看是否引用虚拟环境下pipwhich python #查看是否引用虚拟环境下python版本pip -l # 查看安装了那些包pip install package_name [-update]#安装第三方库pip download package_name &gt;= | == version_number bash配置 .bashrc 1234567891011121314151617181920212223#!/usr/bin/env bashexport APP_HOME=/d/Program\ Files/# some more ls aliasesalias ll=&apos;ls -alF&apos; alias la=&apos;ls -A&apos; alias l=&apos;ls -CF&apos;alias grep=&apos;grep -i --color&apos;# enable color support of ls and also add handy aliases if [ -x /usr/bin/dircolors ]; then test -r ~/.dircolors &amp;&amp; eval &quot;$(dircolors -b ~/.dircolors)&quot; || eval &quot;$(dircolors -b)&quot; alias ls=&apos;ls --color=auto&apos; #alias dir=&apos;dir --color=auto&apos; #alias vdir=&apos;vdir --color=auto&apos; alias grep=&apos;grep --color=auto&apos; alias fgrep=&apos;fgrep --color=auto&apos; alias egrep=&apos;egrep --color=auto&apos; fi # source ~/.colors.theme.bashPS1=&quot;\e[35;40m\t\e[33;49m \u@\h \e[0m☆ \e[34;49m\w\n\e[36;49m➣ \e[0m&quot;# PS1=&quot;\e[37;40m\][\[\e[32;40m\]\u\[\e[37;40m\]@\h \[\e[36;40m\]\w\[\e[0m\]\\$ &quot; .inputrc 1234567891011121314set completion-ignore-case on&quot;\e[A&quot;: history-search-backward&quot;\e[B&quot;: history-search-forward&quot;\e[1~&quot;: beginning-of-line&quot;\e[4~&quot;: end-of-line&quot;\e[5~&quot;: beginning-of-history&quot;\e[6~&quot;: end-of-history&quot;\e[3~&quot;: delete-char&quot;\e[2~&quot;: quoted-insert&quot;\e[5C&quot;: forward-word&quot;\e[5D&quot;: backward-word&quot;\e[1;5C&quot;: forward-word&quot;\e[1;5D&quot;: backward-word .vimrc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307map &lt;F9&gt; :call SaveInputData()&lt;CR&gt;func! SaveInputData() exec &quot;tabnew&quot; exec &apos;normal &quot;+gP&apos; exec &quot;w! /tmp/input_data&quot;endfunc&quot;colorscheme torte&quot;colorscheme murphy&quot;colorscheme desert &quot;colorscheme desert &quot;colorscheme elflordcolorscheme ron&quot;set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936&quot;set termencoding=utf-8&quot;set encoding=utf-8&quot;set fileencodings=ucs-bom,utf-8,cp936&quot;set fileencoding=utf-8&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 显示相关 &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;set shortmess=atI &quot; 启动的时候不显示那个援助乌干达儿童的提示 &quot;winpos 5 5 &quot; 设定窗口位置 &quot;set lines=40 columns=155 &quot; 设定窗口大小 set go= &quot; 不要图形按钮 &quot;color asmanian2 &quot; 设置背景主题 &quot;set guifont=Courier_New:h10:cANSI &quot; 设置字体 &quot;syntax on &quot; 语法高亮 autocmd InsertLeave * se nocul &quot; 用浅色高亮当前行 autocmd InsertEnter * se cul &quot; 用浅色高亮当前行 &quot;set ruler &quot; 显示标尺 set showcmd &quot; 输入的命令显示出来，看的清楚些 &quot;set cmdheight=1 &quot; 命令行（在状态行下）的高度，设置为1 &quot;set whichwrap+=&lt;,&gt;,h,l &quot; 允许backspace和光标键跨越行边界(不建议) &quot;set scrolloff=3 &quot; 光标移动到buffer的顶部和底部时保持3行距离 set novisualbell &quot; 不要闪烁(不明白) set statusline=%F%m%r%h%w\ [FORMAT=%&#123;&amp;ff&#125;]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %&#123;strftime(\&quot;%d/%m/%y\ -\ %H:%M\&quot;)&#125; &quot;状态行显示的内容 set laststatus=1 &quot; 启动显示状态行(1),总是显示状态行(2) set foldenable &quot; 允许折叠 set foldmethod=manual &quot; 手动折叠 &quot;set background=dark &quot;背景使用黑色 set nocompatible &quot;去掉讨厌的有关vi一致性模式，避免以前版本的一些bug和局限 &quot; 显示中文帮助if version &gt;= 603 set helplang=cn set encoding=utf-8endif&quot; 设置配色方案&quot;colorscheme murphy&quot;字体 &quot;if (has(&quot;gui_running&quot;)) &quot; set guifont=Bitstream\ Vera\ Sans\ Mono\ 10 &quot;endif &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;新文件标题&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;新建.c,.h,.sh,.java文件，自动插入文件头 autocmd BufNewFile *.cpp,*.[ch],*.sh,*.java exec &quot;:call SetTitle()&quot; &quot;&quot;定义函数SetTitle，自动插入文件头 func SetTitle() &quot;如果文件类型为.sh文件 if &amp;filetype == &apos;sh&apos; call setline(1,&quot;\#########################################################################&quot;) call append(line(&quot;.&quot;), &quot;\# File Name: &quot;.expand(&quot;%&quot;)) call append(line(&quot;.&quot;)+1, &quot;\# Author: harvey&quot;) call append(line(&quot;.&quot;)+2, &quot;\# mail: sa615341@mail.ustc.edu.cn&quot;) call append(line(&quot;.&quot;)+3, &quot;\# Created Time: &quot;.strftime(&quot;%c&quot;)) call append(line(&quot;.&quot;)+4, &quot;\#########################################################################&quot;) call append(line(&quot;.&quot;)+5, &quot;\#!/bin/bash&quot;) call append(line(&quot;.&quot;)+6, &quot;&quot;) else call setline(1, &quot;/*************************************************************************&quot;) call append(line(&quot;.&quot;), &quot; &gt; File Name: &quot;.expand(&quot;%&quot;)) call append(line(&quot;.&quot;)+1, &quot; &gt; Author: harvey&quot;) call append(line(&quot;.&quot;)+2, &quot; &gt; Mail: sa615341@mail.ustc.edu.cn&quot;) call append(line(&quot;.&quot;)+3, &quot; &gt; Created Time: &quot;.strftime(&quot;%c&quot;)) call append(line(&quot;.&quot;)+4, &quot; ************************************************************************/&quot;) call append(line(&quot;.&quot;)+5, &quot;&quot;) endif if &amp;filetype == &apos;cpp&apos; call append(line(&quot;.&quot;)+6, &quot;#include &lt;iostream&gt;&quot;) call append(line(&quot;.&quot;)+7, &quot;using namespace std;&quot;) call append(line(&quot;.&quot;)+8, &quot;&quot;) endif if &amp;filetype == &apos;c&apos; call append(line(&quot;.&quot;)+6, &quot;#include &lt;stdio.h&gt;&quot;) call append(line(&quot;.&quot;)+7, &quot;&quot;) endif &quot; if &amp;filetype == &apos;java&apos; &quot; call append(line(&quot;.&quot;)+6,&quot;public class &quot;.expand(&quot;%&quot;)) &quot; call append(line(&quot;.&quot;)+7,&quot;&quot;) &quot; endif &quot;新建文件后，自动定位到文件末尾 autocmd BufNewFile * normal Gendfunc &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;键盘命令&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;nmap &lt;leader&gt;w :w!&lt;cr&gt;nmap &lt;leader&gt;f :find&lt;cr&gt;&quot; 映射全选+复制 ctrl+amap &lt;C-A&gt; ggVGYmap! &lt;C-A&gt; &lt;Esc&gt;ggVGYmap &lt;F12&gt; gg=G&quot; 选中状态下 Ctrl+c 复制vmap &lt;C-c&gt; &quot;+y&quot;去空行 nnoremap &lt;F2&gt; :g/^\s*$/d&lt;CR&gt; &quot;比较文件 nnoremap &lt;C-F2&gt; :vert diffsplit &quot;新建标签 map &lt;M-F2&gt; :tabnew&lt;CR&gt; &quot;列出当前目录文件 map &lt;F3&gt; :tabnew .&lt;CR&gt; &quot;打开树状文件目录 map &lt;C-F3&gt; \be &quot;C，C++ 按F5编译运行map &lt;F5&gt; :call CompileRunGcc()&lt;CR&gt;func! CompileRunGcc() exec &quot;w&quot; if &amp;filetype == &apos;c&apos; exec &quot;!g++ % -o %&lt;&quot; exec &quot;! ./%&lt;&quot; elseif &amp;filetype == &apos;cpp&apos; exec &quot;!g++ % -o %&lt;&quot; exec &quot;! ./%&lt;&quot; elseif &amp;filetype == &apos;java&apos; exec &quot;!javac %&quot; exec &quot;!java %&lt;&quot; elseif &amp;filetype == &apos;sh&apos; :!./% elseif &amp;filetype == &apos;py&apos; exec &quot;!python %&quot; exec &quot;!python %&lt;&quot; endifendfunc&quot;C,C++的调试map &lt;F8&gt; :call Rungdb()&lt;CR&gt;func! Rungdb() exec &quot;w&quot; exec &quot;!g++ % -g -o %&lt;&quot; exec &quot;!gdb ./%&lt;&quot;endfunc&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;实用设置&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 设置当文件被改动时自动载入set autoread&quot; quickfix模式autocmd FileType c,cpp map &lt;buffer&gt; &lt;leader&gt;&lt;space&gt; :w&lt;cr&gt;:make&lt;cr&gt;&quot;代码补全 set completeopt=preview,menu &quot;允许插件 filetype plugin on&quot;共享剪贴板 set clipboard+=unnamed &quot;从不备份 set nobackup&quot;make 运行:set makeprg=g++\ -Wall\ \ %&quot;自动保存set autowriteset ruler &quot; 打开状态栏标尺set cursorline &quot; 突出显示当前行set magic &quot; 设置魔术set guioptions=T &quot; 隐藏工具栏set guioptions-=m &quot; 隐藏菜单栏&quot;set statusline=\ %&lt;%F[%1*%M%*%n%R%H]%=\ %y\ %0(%&#123;&amp;fileformat&#125;\ %&#123;&amp;encoding&#125;\ %c:%l/%L%)\&quot; 设置在状态行显示的信息set foldcolumn=0set foldmethod=indent set foldlevel=3 set foldenable &quot; 开始折叠&quot; 不要使用vi的键盘模式，而是vim自己的set nocompatible&quot; 语法高亮set syntax=on&quot; 去掉输入错误的提示声音set noeb&quot; 在处理未保存或只读文件的时候，弹出确认set confirm&quot; 自动缩进set autoindentset cindent&quot; Tab键的宽度set tabstop=4&quot; 统一缩进为4set softtabstop=4set shiftwidth=4&quot; 不要用空格代替制表符set noexpandtab&quot; 在行和段开始处使用制表符set smarttab&quot; 显示行号set number&quot; 历史记录数set history=1000&quot;禁止生成临时文件set nobackupset noswapfile&quot;搜索忽略大小写set ignorecase&quot;搜索逐字符高亮set hlsearchset incsearch&quot;行内替换set gdefault&quot;编码设置set enc=utf-8set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936&quot;语言设置set langmenu=zh_CN.UTF-8set helplang=cn&quot; 我的状态行显示的内容（包括文件类型和解码）&quot;set statusline=%F%m%r%h%w\ [FORMAT=%&#123;&amp;ff&#125;]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %&#123;strftime(\&quot;%d/%m/%y\ -\ %H:%M\&quot;)&#125;&quot;set statusline=[%F]%y%r%m%*%=[Line:%l/%L,Column:%c][%p%%]&quot; 总是显示状态行set laststatus=2&quot; 命令行（在状态行下）的高度，默认为1，这里是2set cmdheight=2&quot; 侦测文件类型filetype on&quot; 载入文件类型插件filetype plugin on&quot; 为特定文件类型载入相关缩进文件filetype indent on&quot; 保存全局变量set viminfo+=!&quot; 带有如下符号的单词不要被换行分割set iskeyword+=_,$,@,%,#,-&quot; 字符间插入的像素行数目set linespace=0&quot; 增强模式中的命令行自动完成操作set wildmenu&quot; 使回格键（backspace）正常处理indent, eol, start等set backspace=2&quot; 允许backspace和光标键跨越行边界set whichwrap+=&lt;,&gt;,h,l&quot; 可以在buffer的任何地方使用鼠标（类似office中在工作区双击鼠标定位）set mouse=aset selection=exclusiveset selectmode=mouse,key&quot; 通过使用: commands命令，告诉我们文件的哪一行被改变过set report=0&quot; 在被分割的窗口间显示空白，便于阅读set fillchars=vert:\ ,stl:\ ,stlnc:\&quot; 高亮显示匹配的括号set showmatch&quot; 匹配括号高亮的时间（单位是十分之一秒）set matchtime=1&quot; 光标移动到buffer的顶部和底部时保持3行距离set scrolloff=3&quot; 为C程序提供自动缩进set smartindent&quot; 高亮显示普通txt文件（需要txt.vim脚本）au BufRead,BufNewFile * setfiletype txt&quot;自动补全:inoremap ( ()&lt;ESC&gt;i:inoremap ) &lt;c-r&gt;=ClosePair(&apos;)&apos;)&lt;CR&gt;&quot;:inoremap &#123; &#123;&lt;CR&gt;&#125;&lt;ESC&gt;O&quot;:inoremap &#125; &lt;c-r&gt;=ClosePair(&apos;&#125;&apos;)&lt;CR&gt;:inoremap [ []&lt;ESC&gt;i:inoremap ] &lt;c-r&gt;=ClosePair(&apos;]&apos;)&lt;CR&gt;:inoremap &quot; &quot;&quot;&lt;ESC&gt;i:inoremap &apos; &apos;&apos;&lt;ESC&gt;ifunction! ClosePair(char) if getline(&apos;.&apos;)[col(&apos;.&apos;) - 1] == a:char return &quot;\&lt;Right&gt;&quot; else return a:char endifendfunctionfiletype plugin indent on &quot;打开文件类型检测, 加了这句才可以用智能补全set completeopt=longest,menu&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;NERDtee设定let NERDChristmasTree=1let NERDTreeAutoCenter=1let NERDTreeBookmarksFile=$VIM.&apos;\Data\NerdBookmarks.txt&apos;let NERDTreeMouseMode=2let NERDTreeShowBookmarks=1let NERDTreeShowFiles=1let NERDTreeShowHidden=1let NERDTreeShowLineNumbers=1let NERDTreeWinPos=&apos;left&apos;let NERDTreeWinSize=31nnoremap f :NERDTreeTogglemap &lt;F7&gt; :NERDTree&lt;CR&gt; ssh/scp免密码登陆123ssh-keygen -t rsa# 由于免密码，密码置为空scp .ssh/id_rsa.pub harvey@192.168.12.128:/home/harvey/.ssh/authorized_keys ATTENTION在Linux上各目录的权限为，注意不要轻易给others写权限即可 1234drwxrwxr-x 2 harvey harvey 4096 May 7 17:52 ./(/home/harvey/.ssh 775)drwxr-xr-x 27 harvey harvey 4096 May 7 22:46 ../(/home/harvey 755)-rw-r--r-- 1 harvey harvey 400 May 7 17:51 authorized_keys (644)]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>pip</tag>
        <tag>ssh</tag>
        <tag>virtualenv</tag>
        <tag>bash</tag>
        <tag>cmder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Snacks]]></title>
    <url>%2F2017%2F04%2F04%2FPython%20Snacks%2F</url>
    <content type="text"><![CDATA[Abstract 刷题专用12345678910111213141516171819#coding:utf-8import systry: sys.stdin = open(__file__.split(&quot;.&quot;)[0]+&quot;.txt&quot;); except IOError, e: print e; print &quot;Please input manully&quot;; while(True): try: n = int(raw_input()); nums = map(int, raw_input().split(&quot; &quot;)); print(nums); nums.sort(); k = int(raw_input()); print(nums) print(nums[k + 1]); except EOFError: break; 测试脚本专用使用subprocess模块调用系统命令或这可执行程序，将返回的结果保存到pipe中，之后使用便利的python字符串操作来记录结果。123456789101112131415161718#! /usr/bin/python#coding:utf-8import subprocess as sptimers = [];cnt = 20;for i in range(cnt): p = sp.Popen([&quot;./target&quot;, &quot;-a -b b&quot;], shell=True, stdout=sp.PIPE); output = p.stdout.read().split(); #print output; tmp = []; for item in output: if(item.find(&quot;us&quot;) &gt; 0): tmp.append(item[:item.index(&quot;us&quot;)]); if(len(tmp)&gt;0): timers.append(map(float, tmp));for i in timers: print i]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenStack Installation Instruction]]></title>
    <url>%2F2017%2F03%2F25%2FOpenStack-Installation-Instruction%2F</url>
    <content type="text"><![CDATA[Abstract记录自己在装OpenStack时遇到的坑主流程参照陈沙克老师的博客和DevStack官网，主要参考陈沙克老师的==local.conf== 文件，修改了其中主机IP，固定IP等看完了OpenStack Configuration那部分的文档，之后再做修改，预计与创建的实例连接外网有关。尽管官网介绍的步骤非常简单，但是自己配置各种出错，按照博客中的原话，多执行脚本几次错误就过去了(网络问题)。 VMware 网络配置VMware三种网络模式讲解Ubuntu网络配置讲解配置信息12345678910111213141516171819VMware：12.0 proWindows：Win10Ubuntu：14.04(推荐)Windows IP：192.168.1.108GW：192.168.1.1VMware- NAT Mode：利用主机的IP联网，有自己的网段，可配置IP：192.168.12.132GW：192.168.12.2MASK：255.255.255.0-Bridge Mode：和Windows的IP在同一网段，这和windows 路由器配置有关IP：192.168.1.xGW：192.168.1.1MASK：255.255.255.0 NAT模式在使用ssh连接时不容易掉线，而桥接模式容易被挤掉，出现==Connection closed by foreign host.== 错误。在Windows下可以使用ipconfig查看ip设置，使用arp -a查看与虚拟机是否建立了连接，使用之前最好刷新一下虚拟机的网络，比如在虚拟机中上下网什么的。在虚拟机Ubuntu中可以编辑 ==/etc/network/interfaces== 文件 VMware虚拟机配置 需要配置多核且能虚拟化虚拟机网络配置，VMware默认是NAT模式配地址，默认网关是192.168.x.2如果虚拟机没有自动连接网络，需点击一下Auto Ethernet，或者自己编辑网络地址 准备事项和错误 同步网络时间的方法博客中关于同步时间的指令，不能执行，我参考了网上的。 修改/etc/sudoers文件使得==harvey==用户和==stack==使用sudo命令可以不用输入密码 HASH和不匹配问题 vi /etc/apt/source.list注释掉无法解析的extras源，顺便说明一下，这个问题是通过Ubuntu 图形化界面选择源的，所以保留一些国外的源，就会产生问题，如果是国内的镜像出现这种问题，可以通过修改访问方式https或者修改/etc/resolv.conf文件中namesever为源相应的域名(没有亲测) 安装过程中碰到从https://pypi.python.org/中下载wheel文件过慢的问题 可以参考加快从pipy中下载的速度 也可以通过wget在pypi网站命令提前下载好 也可以直接在pypi网站 1234567#添加豆瓣源，直接复制一下内容即可mkdir ~/.pipcat &gt; ~/.pip/pip.conf &lt;&lt;EOF[global]index-url = http://pypi.douban.com/simple/trusted-host = pypi.douban.comEOF 通过sudo find / -regex &quot;.+\.whl$&quot;命令找到下载好的==whl==文件存放目录 在upper-requirements.txt:271需要的版本是4.0.2，文件大小为13.7M，我在pypi上找到的版本是4.4.0版本文件大小为4.3M。由于文件太大，下载容易出错，再来一次就好。或者使用wget 下载好放在/usr/local/lib/python2.7/dist-packages目录中 OpenstackSDK错误 ![OpenstackSDK ERROR][12] 修正方法有以下几种： 将openstacksdk的版本调至0.9.11或者0.9.12 可以将出错模块==session.py==文件中.__version__给去掉 安装成功]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OpenStack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序运行时间测定]]></title>
    <url>%2F2016%2F10%2F22%2F%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E6%B5%8B%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[简介封装了一个简单获取当前时间戳的函数double getCurrentTimestamp()，该函数能够在Windows和Linux下运行 话不多说，源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#ifdef _WIN32 #include &lt;windows.h&gt;#else #include &lt;unistd.h&gt; #include &lt;time.h&gt;#endifdouble getCurrentTimeStamp()&#123; double current; #ifdef _WIN32 static LARGE_INTEGER fre = &#123;&#125;; LARGE_INTEGER cur_clock; if(0 == fre.QuadPart) QueryPerformanceFrequency(&amp;fre); QueryPerformanceCounter(&amp;cur_clock); current = (double)cur_clock.QuadPart / (double)fre.QuadPart; #else struct timespec ts; clock_gettime(CLOCK_MONOTONIC, &amp;ts); current = (double)ts.tv_nsec * 10e-9 + (double)ts.tv_sec; #endif return current;&#125;int main()&#123; double start, end; start = getCurrentTimeStamp(); int sum = 0, i; for(i = 0; i &lt; 10000000; i++) &#123; sum += i; &#125; end = getCurrentTimeStamp(); printf("time %f seconds\n", end - start); return 0;&#125; 代码注释_WIN32GCC编译器自带的编译宏，能够识别判别代码是否在Windows下编译。查看自带编译宏的指令gcc -posix -E -dM - &lt;/dev/null QueryPerformanceCounter()精确的时间计时，有时候是非常必要的。比如播放多媒体时视频与音频的时间同步，还有在测试代码的性能时，也需要使用到非常精确的时间计时。还有测试硬件的性能时，也需要精确的时间计时。这时就需要使用QueryPerformanceCounter来查询定时器的计数值，如果硬件里有定时器，它就会启动这个定时器，并且不断获取定时器的值，这样的定时器精度，就跟硬件时钟的晶振一样精确的。QueryPerformanceCounter 查询性能计数器 The QueryPerformanceCounter function retrieves the current value ofthe high-resolution performance counter, if one exists.此函数用于获取精确的性能计数器数值,如果存在. 123BOOL QueryPerformanceCounter( LARGE_INTEGER *lpPerformanceCount // address of current counter value 当前计数器值的地址 ); //Parameters lpPerformanceCountPoints to a variable that the function sets, in counts, to the current performance-counter value. If the installed hardware does not support a high-resolution performance counter, this parameter can be to zero.指针,指向函数设置的一个变量(一般是个引用,译者注), 用来返回性能计数器的值.如果已安装的硬件不支持高精度性能计数器,此参数可以为0(那调用有什么意义,用来查询?). Return ValuesIf the installed hardware supports a high-resolution performance counter, the return value is nonzero. 不支持，返回非0，否则返回0If the installed hardware does not support a high-resolution performance counter, the return value is zero.函数通常和QueryPerformanceFrequency配合使用，换算出秒数 clock_gettime() 函数”clock_gettime”是基于Linux C语言的时间函数,他可以用于计算精度和纳秒 123456789101112131415#include&lt;time.h&gt;int clock_gettime(clockid_t clk_id,struct timespec *tp);/*参数clk_id : 检索和设置的clk_id指定的时钟时间。CLOCK_REALTIME:系统实时时间,随系统实时时间改变而改变,即从UTC1970-1-1 0:0:0开始计时,中间时刻如果系统时间被用户改成其他,则对应的时间相应改变 CLOCK_MONOTONIC :从系统启动这一刻起开始计时,不受系统时间被用户改变的影响 CLOCK_PROCESS_CPUTIME_ID:本进程到当前代码系统CPU花费的时间 CLOCK_THREAD_CPUTIME_ID:本线程到当前代码系统CPU花费的时间*/struct timespec&#123;time_t tv_sec; /* 秒*/long tv_nsec; /* 纳秒*/&#125;;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Windows</tag>
        <tag>时间测定</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux服务器常用配置方法]]></title>
    <url>%2F2016%2F10%2F15%2FLinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[常用的Linux环境配置，使编程更有效率 利用Samba实现服务器和windows下文件共享1234567891011121314151617181920212223242526# 1. 安装sambasudo apt-get install samba# 2. 添加系统用户sudo adduser # 3. 添加系统用户目录（如果使用adduser 这步可以省掉）cd /homemkdir usernamechown -R username# 4. 添加samba用户sudo smbpasswd -a username# 5. 配置sambavi /etc/samba/smb.conf[username] comment = shared dir with username path = /home/username browseable = yes writable = yes read only = no guest ok = no# 6. 重启samba/etc/init.d/samba restart 修改Linux主机名 暂时修改，下次会话生效 1234# 方法一 hostname newhostname# 方法二 sysctl kernel.hostname 永久性修改 123vi /etc/hostname# 如果没有上面的目录的话vi /etc/sysconfig/hostname 用户相关usermod 选项12345678910111213-a|--append ##把用户追加到某些组中，仅与-G选项一起使用 -c|--comment ##修改/etc/passwd文件第五段comment -d|--home ##修改用户的家目录通常和-m选项一起使用 -e|--expiredate ##指定用户帐号禁用的日期，格式YY-MM-DD -f|--inactive ##用户密码过期多少天后采用就禁用该帐号，0表示密码已过期就禁用帐号，-1表示禁用此功能，默认值是-1 -g|--gid ##修改用户的gid，改组一定存在-G|--groups ##把用户追加到某些组中，仅与-a选项一起使用 -l|--login ##修改用户的登录名称 -L|--lock ##锁定用户的密码 -m|--move-home ##修改用户的家目录通常和-d选项一起使用 -s|--shell ##修改用户的shell -u|--uid ##修改用户的uid，该uid必须唯一 -U|--unlock ##解锁用户的密码 新建用户test，密码test，添加用户组usertest 123# adduser test# 根据提示输入密码等信息# groupadd usertest 将test用户添加到usertest用户组 123#usermod -aG usertest test ##多个组之间用空格隔开 #id test uid=500(test) gid=500(test) groups=500(test),501(usertest) 修改test用户Home目录 123#usermod -md /home/usertest #ls /home usertest 修改用户名 123#usermod -l urchin(新用户名称) test(原来用户名称) #id urchin uid=500(urchin) gid=500(test) groups=500(test),501(usertest) 修改用户shell 12345#sed &apos;$!d&apos; /etc/passwd urchin:x:500:500::/home/usertest:/bin/bash #usermod -s /bin/sh urchin #sed -n &apos;$p&apos; /etc/passwd urchin:x:500:500::/home/usertest:/bin/sh (当然bash更好用)]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Samba</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + Github 搭建个人博客]]></title>
    <url>%2F2016%2F08%2F28%2FHexo%20%2B%20Github%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[看见网上的大神们在github上搭建自己的博客，便也手痒了，也想搭一个，本文记载了搭建博客的整个过程 申请git账号新建一个和自己用户名一样的repositoryFor example，我的github的用户名时HarveyHub，所以我建的repository名为 HarveyHub.github.io 本地安装git添加SSHkey 参考git学习笔记中环境配置，添加SSH key下载安装nodejs nodejs中文官网 下载安装Hexo 安装好nodejs之后，可以使用npm install hexo-cli -g名利安装Hexo开始搭建一个hello world博客 新建blog文件夹 hexo init blog npm install hexo generate也可以简写为hexo g hexo server启动本地服务器，进入http://localhost:4000 预览 修改blog目录下的配置文件_config.yml 1234deploy: type: git repo: https://github.com/HarveyHub/HarveyHub.github.io.git branch: master 执行命令npm install hexo-deployer-git --save 这时使用hexo deploy命令发布网站之后，就会在 harveyhub.github.io访问到helloworld博客。 写一篇自己的博文并发布 hexo new &quot;postName&quot; #新建文章，在source/_post/中生成postName.md文件 hexo new &quot;pageName&quot; #新建页面 hexo generate #生成静态页面到public目录 hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo deploy #发布博文，将github作为静态网站的服务器 hexo help #查看帮助 hexo version #查看hexo版本应用主题Hexo All Themes中有很多主题，git clone到本地blog/themes，把blog根目录中 _config.yml 中theme:对应的值改为主题名，之后一步步按照readme.md文件中安装主题 博客维护 hexo new &quot;postName&quot;/&quot; hexo new page &quot;pageName&quot; hexo clean删除public文件夹中已经生成的静态页面，让人不爽的是把图片也删除了。这样markdown文件里面的图片就不能在网页中显示了。 hexo generate 如果markdown文件中引用了图片，记得把图片放入到public中博文相应的目录，因为git clean之后图片会被删除。 hexo deploy 添加图片 在source文件夹下建一个images文件夹，把需要放在网上的图片修改好名字放在其中 在md文件中包含图片时使用 1![image decription](/imags/image_name.jpg) 在小书匠编辑器中更改库为小书匠编辑器存储，资源引用路径改为images的上级目录，这样既能在小书匠编辑器中预览到图片，也能够将图片发布到网页中，不需要每次把图片考入public中博文相对应的目录中 hexo文章模板 模板可按个人需求修改 123456789title: 博文名date: 时间日期categories: - 文章分类名1 - 文章分类名2tags: - 文章标签1 - 文章标签2top: 1 #文章置顶 文章分类、文章标签分类需要主题支持 小书匠新建MD文件模板12345678910111213141516---title: New File.md date: &lt;% print((new Date()).toLocaleString()); %&gt;categories: - 学习tags: - gittop: 1grammar_cjkRuby: true---&gt; Abstract&lt;Excerpt in index&gt; &lt;!-- more --&gt;]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git学习笔记]]></title>
    <url>%2F2016%2F08%2F28%2Fgit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[学习廖雪峰git教程的笔记 安装git 可以从git官方下载网站下载对应的git版本，安装过程中一路next即可；linux下直接使用命令sudo apt-get install git安装 需要配置local信息 12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 常用命令及其功能本地仓库 git init，将当前目录变成Git可以管理的仓库 git add &quot;existed file/folder，将该文件提交到stage，当后面是文件夹时，提交该文件夹下所有内容 git commit -m &quot;describe of commition&quot;，将git add提交到stage的内容提交到仓库中。 git status查看仓库当前状态。 git diff &quot;file name&quot;，比较仓库中filename文件和工作区中该文件的区别 git log或git log --pretty=online，显示从最近到最远的提交日志 gitk可进入图形界面 git reset --hard HEAD^，将工作区中的内容回溯到上一次提交之前。HEAD表示当前版本，上一个版本时HEAD^，上上个版本是HEAD^^，往前N个版本就是HEAD~N。git reset --hard之后也可以接版本ID（很长的一串数字）。 git reflog用来记录每一次命令，上面有之前提交的版本号，这样方便回溯或切换到之后版本。 git checkout -- file，检出file在库中的版本，这会覆盖掉工作区中的file，从而实现的功能是撤销工作区文件的删改，git reset HEAD file把stage中的file撤销掉 git rm &quot;file&quot;删除仓库中file文件。使用完该命令之后就不能从仓库中git chechout &quot;file&quot;检出该文件了。如果只是本地删除，可以检出恢复。 ssh-keygen -t rsa -C &quot;your email@example.com&quot;，创建SSH Key，一路回车下去，就会发现在用户目录下有.ssh目录，目录中会有id_rsa和id_rsa.pub，这两个是SSH Key密钥对，id_rsa是私钥，不能泄露，id_rsa.pub是公钥，可以放心的告诉别人。登陆GitHub，点击右边自己的头像打开Setting，左边的列表中会有SSH and GPG keys，点击之后在右边会看到New SSH Key，填上Title，在Key文本框里粘贴id_rsa.pub中的内容。点Add SSH Key，就可以看到已经添加的Key。若是希望每次提交的时候不输入密码，需要将push方式改为ssh方式，而不是https方式。可以通过修改当前repository目录下.git/config中的url 1234#https方式url = https://github/HarveyHub/Python# ssh方式url = git@github.com:HarveyHub/Python 远程仓库 关联远程仓库和本地仓库，在GitHub创建好空的repository之后，根据提示关联已经有的本地仓库，在本地仓库目录下执行 12git remote add origin https://github.com/your_name/repository_name.gitgit push -u origin master 提交本地仓库所有内容，-u表示将本地master分支与远程的origin分支关联起来，在以后的推送和拉取时可以简化命令为git push origin master将本地库的内容推送到远程。 git clone https://github.com/your_name/repository_name.git将远程库中内容拷贝到本地，也可以达到关联的目的。 git remote -v查看远程库信息 git pull 从远程抓取分支，每次提交本地库到远程库之前执行，如有冲突，先处理冲突. 分支相关命令 12345678git branch //查看已有分支，当前分支会有*标志git branch dev //创建分支git checkout dev //切换该分支git checkout -b &lt;name&gt; //创建+切换分支git merge &lt;name&gt; //将某分支合并到当前分支上git branch -d &lt;name&gt; //删除某分支 git branch -D &lt;name&gt; //强制删除分支 git branch --set-upstream branch-name origin/branch-name 分支合并： Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，当合并分支出新冲突时，用git status查看具体情况，再手动修改合，排除冲突后进行合并。 git log --graph，查看分支合并图 --no-ff，合并分支时使用此参数，合并后的历史有分支，可以看出来哪些曾经修改过。 git stash，储存当前工作现场，使用git stash list查看存储的工作现场，使用git stash applay恢复（需要使用git stash drop删除stash内容）， 或者使用git stash pop恢复的同时将stash的内容删除 标签操作git tag &lt;name&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id；git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息；git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;可以用PGP签名标签；git tag可以查看所有标签。git push origin &lt;tagname&gt;可以推送一个本地标签；git push origin --tags可以推送全部未推送过的本地标签；git tag -d &lt;tagname&gt;可以删除一个本地标签；git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签 其他git config --global color.ui true:让Git显示颜色，会让命令输出看起来更醒目.gitignore忽略特殊文件，用户可以修改指定忽略的文件]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[notepad++配置]]></title>
    <url>%2F2016%2F08%2F27%2Fnotepad%2B%2B%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[引言 相信大家一般都苦于使用什么样的IDE编辑一些比较小的程序，VS太过于庞大，不适合新手理解CC程序怎么从源码到可执行程序的过程，并且VS编译出来的项目只有对方安装了VS才能使用。今天记录一下如何在notepad++上编辑执行CC Python Java代码。 前期工作 安装好Python环境，在安装时勾选Add python.exe to Path 这样做的好处是，不需要另外为python添加环境变量 安装好MinGW，即windows环境下的GCC。这个可以从Code-Block或者Dev-Cpp中抽取，毕竟从官网中下载太过麻烦。 安装好JDK和JRE（如果你想使用notepad++编辑java程序），并为之配置环境变量 在notepad++中安装NppExec插件，在插件管理器中能够找到。 添加执行脚本 安装完NppExec 之后，点击 ==F6== 键便可键入脚本，输入下面的脚本之后保存。 CC执行脚本 123456npp_savecd $(CURRENT_DIRECTORY)echo ======start to compile========g++ -g -Wall -std=c++11 &quot;$(FILE_NAME)&quot; -o &quot;$(NAME_PART)&quot;echo ======start to execute=======&quot;$(NAME_PART)&quot; 名字保存为g++，当然如果平时编辑gcc比较多的话，按照上面的例子修改即可。g++的编译选项实现了测试，显示所有警告，使用C++11标准，这里可以按需修改。 Python执行脚本 1234 npp_savecd $(CURRENT_DIRECTORY)echo ======start to execute=======python &quot;$(FILE_NAME)&quot; 名字保存为python。 JAVA执行脚本 123456npp_savecd $(CURRENT_DIRECTORY)echo ======start to compile========javac &quot;$(FILE_NAME)&quot;echo ======start to execute=======java &quot;$(NAME_PART)&quot; 名字保存为java 为执行脚本添加快捷键添加快捷键的方法自行百度。]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Notepad++</tag>
        <tag>CC</tag>
      </tags>
  </entry>
</search>